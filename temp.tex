\documentclass{article}
\usepackage{graphicx}
\usepackage{geometry}
 \geometry{
 a4paper,
% total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm,
 }
\graphicspath{ {/home/synchro/Pictures/} }
\setlength{\tabcolsep}{2pt}
\setlength\emergencystretch\textwidth
\usepackage{listings}
\documentclass{article}
\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\begin{document}

\title{\textbf{Embedded Real-Time Systems}}
\author{Ali Alessio Salman, Bastiaan Gris\`el, Henko Aantjes}

\maketitle

\begin{abstract}
\begin{center}
The abstract text goes here. 
\end{center}
\end{abstract}

\section{Introduction}
Here is the text of the introduction.

\subsection{Protocol Design}
Due to bandwidth restrictions we've decided to use a 24 bits packets for each message from the PC to the X32 soft-core. The first int\_8 number will be the preamble of the packet; the table below shows what is the correspondence with the commands (Mode, Lift, Roll, Pitch, etc.). The next 8 bits carry the real information that could be the offset, choosing the new mode or the value of the P-control.  
Since we're working on a \textit{real-time} system we don't need to pay special attention to the packet loss because the information in each packet is pretty meager and it's more important to receive the next one than setting up a routine to re-send lost packets that could incur in losing precious time (...).  
The checksum instead is fundamental not to execute the wrong commands that could cause an immediate crash of the QR. 
\vspace{2em}


\begin{table}[h!]
\centering
 \begin{tabular}{||c|c|c|c||} 
 \hline
 Code & Type & Payload & Additional Info \\ [0.5ex] 
 \hline\hline
 0 & M & 3bits to choose the mode + padding & 8bits checksum \\ 
 \hline
 1 & L & 8bits integer value (offset) & 8bits checksum \\
 \hline
 2 & R & 8bits integer value (offset) & 8bits checksum \\
 \hline
 3 & P & 8bits integer value (offset) & 8bits checksum \\
 \hline
 4 & Y & 8bits integer value (offset) & 8bits checksum\\ 
 \hline
 5 & J & 8bits integer value (P-control) & 8bits checksum\\ 
 \hline
 6 & K & 8bits integer value (P-control) & 8bits checksum\\ 
 \hline
 7 & L & 8bits integer value (P-control) & 8bits checksum\\ 
 \hline
\end{tabular}
\caption{Each row describes a packet type (Provisional)}
\label{table:1}
\end{table}

\begin{lstlisting}[language=C, caption=Protocol]
void check_for_new_packets(Fifo *q, void (*callback)(char, PacketData), void (*error)()){
	while(fifo_size(q) >= 4) { // Check if there are one or more packets in the queue
		char control;
		PacketData data;
		char checksum;

		fifo_peek_at(q, &control, 0);
		fifo_peek_at(q, &data.as_bytes[0], 1);
		fifo_peek_at(q, &data.as_bytes[1], 2);
		fifo_peek_at(q, &checksum, 3);

		if(!check_packet(control,data,checksum)) {
			// If the checksum is not correct, pop the first message off the queue and repeat the loop
			char c;
			fifo_pop(q, &c);

			error();
		} else {
			// If the checksum is correct, pop the packet off the queue and notify a callback
			char c;
			fifo_pop(q, &c);
			fifo_pop(q, &c);
			fifo_pop(q, &c);
			fifo_pop(q, &c);

			callback(control, data);
		}
	}
}
\end{lstlisting}

\end{document}
